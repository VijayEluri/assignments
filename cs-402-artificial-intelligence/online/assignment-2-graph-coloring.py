#!/usr/bin/pythonimport copyDEBUG_MODE = Falsedef dprint(*args):	global DEBUG_MODE	if DEBUG_MODE == True:		print 'DEBUG:',		for arg in args: print arg,		printadjacencent = {1: (3, 4, 5, 6),	2: (5, 6),	3: (1, 4, 5),	4: (1, 3, 6),	5: (1, 2, 3, 6),	6: (1, 2, 4, 5)}colors = ['Red', 'Green', 'Blue']def call_dfs(graph):	# return immediately if no free space is found to color	if graph.values().index(None) == -1: return graph	outcome = graph	for node in graph.keys():		dprint('Calling dfs from base for node', node)		outcome = dfs(node, graph)		# if outcome is a valid graph, break, otherwise finish the loop		if outcome != None: break	# if solution found, returns the solution, else returns the original graph	return outcomedef dfs(node, graph):	global colors	global adjacencent	dprint('DFS called for node:', node)	dprint('Current graph:', graph)	outcome = graph	# only if the node is free	if graph[node] == None:		for color in colors:			graph[node] = color			dprint('Coloring node:', node, ', Graph status:', graph)			# check if this color is good			for neighbour in adjacencent[node]:				# color is bad				if graph[node] == graph[neighbour]:					dprint('Node', node, 'and neighbour', neighbour ,'have same color, returning')					return None			# color is good, prepare the next node to color			if node < len(graph):				outcome = dfs(node+1, copy.deepcopy(graph))				if outcome == None:					dprint('DFS returned for color similarity, back at node', node, 'graph is back at', graph)					continue				else:					return outcome			else:				# there is no place to color				return graph	return outcomeif __name__ == '__main__':	graph = dict(zip([x for x in range(1, 7)], [None for x in range(1, 7)])) 	colored_graph = call_dfs(graph) 	print 'Colored graph:', colored_graph